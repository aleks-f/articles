<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title><literal>Dynamic C++</literal></title>
    <author>
        <firstname>Alex</firstname>
        <surname>Fabijanic</surname>
        <email>alex@pocoproject.org</email>
    </author>
    <authorinitials>AF</authorinitials>
</articleinfo>
<simpara>&#8220;As to which is more important, Dynamic or static, both are absolutely essential, even when they are in conflict.&#8221;<?asciidoc-br?>
~<link linkend="ROBPIRS">Robert Pirsig</link></simpara>
<section id="_introduction">
<title>Introduction</title>
<simpara>C++ is a strongly-typed language. The static aspect of the C++ type system provides the data integrity "safety net". Compiler is an indispensable runtime-surprise-prevention tool and the static nature of <literal>C++</literal> provides runtime performance gain - anything that can be done at compile time saves valuable cycles at runtime. There are, however, circumstances calling for a softened type system, where a degree of performance sacrifice is acceptable and runtime type detection desirable (or even necessary). <literal>C++</literal> runtime type detection system (a.k.a. RTTI) is rudimentary; to provide a generic functionality automatically adaptable to different data types at runtime, one has to resort to library-based solutions. For example, data from a remote parts of code as well as external sources may arrive in a variety of types and sometimes brings along the need for efficient and transparent datatype conversion. The proliferation of web-based interfaces and databases with addition of popular textual formats such as JSON and XML exacerbates the need for relaxed type system with transparent and safe conversion facilities. This is a domain where dynamic languages have gained a significant footing. In order to clarify the premises for this writing, we must take a brief detour here &#8230;</simpara>
<note><simpara>One may argue that trying to take <literal>C++</literal> on the dynamic languages turf is an unreasonable endeavor; that is one way of looking at it. But, to get a broader perspective, let&#8217;s enumerate the need and benefits of dynamic typing in <literal>C++</literal>. Dynamic language environments are built on a strongly typed foundation. When the static/dynamic langugage interaction need arises, we embed those foreign language environments and talk to them in a "foreign tongue" (i.e. through a specialized translation layer they expose). Wouldn&#8217;t it be nice to (a) smoothen the rough edge between the two, while (b) addressing the concern of dealing with external data of different types and (c) gain a standard C<literal> dynamic language environment natively and seamlessly as a side-efect? While standard C</literal> claims to be a general-purpose language, it stops abruptly at the point where dynamic-language-like behavior is needed - as things stand at the time of this writing, even a well-known oldie like <literal>bost::any</literal> could only make it to 2014 TS, which means it will not be standardized earlier than 2017. The original spark (boost::any port to Poco) triggering this writing effort was decidedly not about <literal>C++</literal> as a dynamic language but rather about a way to work around the rigid <literal>C++</literal> type system in a reasonably efficient and reusable way. After spending some time dealing with the problem, a surprising revelation occurred; since libraries are languages [TODO: ref], the <literal>C++</literal> library solutions for type dynamics are <literal>C++</literal>'s native dynamic languages of sorts. Suddenly, the idea of a native <literal>C++</literal> "dynamic language" does not sound so outlandish after all &#8230;</simpara></note>
<simpara>We start our journey with a smooth sail - simple, minimalistic and well-known <literal>boost::any</literal> with its deceptively soft typeless conception and surprisingly rigid, ultra-strongly typed delivery interface (or, should we say, lack thereof). As we move on, our journey takes us to rough waters of solutions that endeavor, each in its own way, to provide dynamic facilities within the confines of <literal>C++</literal> and its static type system. The solutions gradually build on existing foundations, attacking the problem from various aspects while trying to keep size, performance and datatype integrity under control.</simpara>
<simpara>Is it possible to provide a dynamic behavior within the constraints of standard ANSI/ISO <literal>C++</literal>? How can a <literal>C++</literal> programmer accurately and efficiently transfer data from a database to XML, JSON or HTML without stumbling over the rigid <literal>C++</literal> static type-checking mechanism at compile time while ensuring accuracy at runtime? Can type-erasure and (checked) type-conversion techniques fit the bill? Given both historical (ANSI C union and void*, MS COM Variant, boost::[variant, any, lexical_cast], QVariant, <literal>adobe::any_regular</literal>) and recent (Boost.TypeErasure, Facebook <literal>folly::dynamic</literal>) development trends (including pending Boost.Any <literal>C++</literal> standard proposal), the need for a way around the static nature of <literal>C++</literal> language is obvious. Since the DynamicAny [ACCUDYN] article, some new solutions [FOLLYDY] have appeared, POCO <xref linkend="POCOPRJ"/> has seen several release cycles and <literal>Poco::DynamicAny</literal> is now known under a new name - <literal>Poco::Dynamic::Var</literal>. Additionally, the performance of number/string conversion has been improved by replacing sscanf/sprintf based conversion with double-conversion <xref linkend="DOUBCON"/> (also used by <literal>folly::dynamic</literal>). In this article series, both externals and internals of boost::[variant, any, type_erasure], <literal>folly::dynamic</literal>, <literal>Poco::Dynamic::Var</literal>, Qt QVariant and <literal>adobe::any_regular</literal> are explored and compared. Design, capabilities, ease of use as well as pros and cons of each solution will be examined. Performance benchmark comparisons results will be provided as well.</simpara>
<simpara>But, first things first - let us start by looking at concerns shaping the solutions and ingredients they&#8217;re made of.</simpara>
</section>
<section id="_dynamic_concerns">
<title>Dynamic Concerns</title>
<simpara>What are the concerns involved with dynamic behavior and how are they solved? Let&#8217;s enumerate, disect and analyze them &#8230;</simpara>
<variablelist><title>Concerns</title>
<varlistentry>
<term>
Storing Value
</term>
<listitem>
<simpara>
This concern has to do with location where the actual bits representing the value reside. Within <literal>C++</literal> memory model, there are two distinct choices - heap and stack. If the value  resides on the heap, we will pay in runtime performance for memory allocation. However, the amount of memory will be variable, commensurate with the size of held type plus platform dependent padding/alignment. If value resides on the stack, we will invariably pay the storage size of the largest value we wish to store. And then, there is a hybrid solution (also known as small object optimization, configurable at compile time) which, to an extent, compromises the stack size concern in order to avoid the heap allocation penalty for types under certain size; this solution, however, imposes runtime penalties of size inspection (a) before instantiation and (b) at every value retrieval.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Performing Operations
</term>
<listitem>
<simpara>
Mostly, operations will boil down to type conversions, between string and numeric values in particular. There are, however, cases where other conversions or transformations are needed; some solutions even provide capability to add custom operations to types at compile time.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Retrieving Value
</term>
<listitem>
<simpara>
Value retrieval ranges from (a) strict requirement for explicit held type to (b) transparent conversion between different types, sometimes with runtime exceptions if conversion is impossible or even undefined behavior if user is not careful. Some solutions come with built-in value retrieval, while some require external "scaffolding" in order to extract the held value.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Runtime Performance
</term>
<listitem>
<simpara>
From the runtime performance standpoint, there will typically be two concerns: heap memory allocation and conversion/transformation costs. From this aspect, anything that could be done at compile time, should. Additionally, as mentioned above, small object optimization affects runtime performance.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Memory Usage
</term>
<listitem>
<simpara>
Memory usage will vary, from (a) exact type size (plus inevitable platform-dependent alignment) to (b) fixed size, large enough to hold the largest stack-based type supported.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Code Size
</term>
<listitem>
<simpara>
The binary code size generated by various solutions will mostly be proportional to the functionality provided. For example, any code will be small due to non-existent conversion logic. Poco::Dynamic::Var code will be the largest, due to exhaustive involvement in type conversions and accuracy checks. The rest of the solutions will be somewhere in between.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Ease of Use
</term>
<listitem>
<simpara>
Last but not least, this concern regards user experience when dealing with dynamic functionality. Some solutions have rigid compile-time constraints, while some others may exhibit surprising runtime behavior, even for intuitive use. If user, in order to use a software component correctly, has to understand its implementation details, the total value of the abstraction is diminished regardless of the implementation quality. Or, as Scott Meyers succintly puts it, <emphasis>"Make interfaces easy to use correctly and hard to use incorrectly"</emphasis>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_ingredients">
<title>Ingredients</title>
<simpara>intro</simpara>
</section>
<section id="_boost_any">
<title>Boost.Any</title>
<simpara>This well-known class has been around for a long time; at the time of this writing, it is an active proposal for standardization [ANYCSTD]. According to proposal authors, <literal>std::any</literal> is a container for "Discriminated types that contain values of different types but do not attempt conversion between them". This classifies any as a generic (generic in the sense of "general", not template-based) solution for the first half of the problem - how to accommodate any type in a single container. The "syntactic sugar" is waived template syntax - any itself is not a template class but it has a template constructor and assignment operator; this is conveniently used to avoid the aesthetically unpleasing angle brackets:</simpara>
<formalpara><title>Listing 1</title><para>
<screen>any a = "42";
any b(42);</screen>
</para></formalpara>
<simpara>What happens "under the hood" is:</simpara>
<itemizedlist>
<listitem>
<simpara>
at compile time, assignment (or construction) code for appropriate type is generated
</simpara>
</listitem>
<listitem>
<simpara>
at run time, value is assigned to a polymorphic holder instantiated on the heap
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Listing 2 - Any constructor</title><para>
<screen>template&lt;typename ValueType&gt;
any(const ValueType &amp; value):content(new holder&lt;ValueType&gt;(value))
{
}</screen>
</para></formalpara>
<simpara>Runtime dynamism is achieved through polymorphism as shown in Listing 3.</simpara>
<formalpara><title>Listing 3</title><para>
<screen>class placeholder
{
public:
        virtual ~placeholder()
        {
        }
// ...
        virtual const std::type_info &amp; type() const = 0;
// ...
}

template&lt;typename ValueType&gt;
class holder : public placeholder
{
public:
        holder(const ValueType &amp; value):held(value)
        {
        }
        // ...
        ValueType held;
    };</screen>
</para></formalpara>
<simpara>Right away, it is obvious that assignment will incur performance penalty due to heap allocation and size/performance penalty due to virtual inheritance. The convenience of any extends from the construction/assignment moment during its lifetime and stops the moment one wants to retrieve the value. Until then, any looks and acts like, well - any value. While it works in a wonderfully transparent manner on the assignment side, the data extraction side is out of any&#8217;s "scope of supply". <literal>Poco::Dynamic::Var</literal> takes off where any stops, providing user-extensible conversion facilities for non pre-specialized types; the design, rationale, use and performance of this class hierarchy is described later in the article.</simpara>
<simpara>Poco::Any [POCOANY] is a port of Boost.Any to POCO with addition of (optional) small object optimization, which prevents the runtime heap-allocation overhead for held objects under certain size.</simpara>
</section>
<section id="_boost_variant">
<title>Boost.Variant</title>
<simpara>According to the authors [BOOSVAR], boost::variant class template is "a safe, generic, stack-based discriminated union container, offering a simple solution for manipulating an object from a heterogeneous set of types in a uniform manner". It determines the needed storage at compile time, uses boost::mpl and limits the runtime capabilities to types defined at compile time.</simpara>
<simpara>The performance penalty of boost::any creation and polymorphic nature, as well as its incapability to provide reliable compile-time type detection were the motivating factors for boost::variant authors. For that reason, variant is stack-based and provides reliable compile-time type detection and value extraction. There is a caveat - to enforce "never empty" requirement, variant may temporarily allocate storage on the heap to keep the old value for case of exception being thrown during assignment. Authors claim to have plans for alleviating this shortcoming.</simpara>
<simpara>Faced with a boost::variant, a na√Øve user may try something like this:</simpara>
<formalpara><title>Listing 4</title><para>
<screen>variant&lt;int, string&gt; v = 1;
string s = v; // compile error
boost::get&lt;std::string&gt;(v); // throws</screen>
</para></formalpara>
<simpara>Authors admit the shortcomings and brittleness of the above approach and provide visitor pattern as a vehicle to unleash the full strength of boost::variant. The visitor is created by inheriting from boost::static_visitor&lt;&gt; class template:</simpara>
<formalpara><title>Listing 5</title><para>
<screen>class my_visitor : public boost::static_visitor&lt;int&gt;
{
public:
        int operator()(int i) const
        { return i; }

        int operator()(const std::string &amp; str) const
         return str.length(); }
};

int main()
{
        boost::variant&lt; int, std::string &gt; u("hello world");
        std::cout &lt;&lt; u; // output: hello world

        int result = boost::apply_visitor( my_visitor(), u );
        std::cout &lt;&lt; result; // output: 11 (i.e., length of "hello world")
}</screen>
</para></formalpara>
<simpara>In order to provide the type conversions, however, user must define a visitor per destination type, e.g. to facilitate the most common conversion between numbers and strings, the following minimal set of classes is needed:</simpara>
<formalpara><title>Listing 6</title><para>
<screen>struct string_int_converter : public boost::static_visitor&lt;int&gt;
{
        int operator()(int i) const;
        int operator()(const std::string &amp; str) const;
        int operator()(double d) const;
};

struct string_dbl_converter : public boost::static_visitor&lt;double&gt;
{
// not needed ?
        //double operator()(int i) const;
        double operator()(const std::string &amp; str) const;
        double operator()(double d) const;
};

struct num_string_converter : public boost::static_visitor&lt;std::string&gt;
{
        std::string operator()(int i) const;
        std::string operator()(const std::string&amp; str) const;
        std::string operator()(double d) const;
};</screen>
</para></formalpara>
<simpara>Internally, the variant data is in-place constructed into the storage allocated at compile time and large enough to accommodate the largest datatype specified; storage is a union of char array plus alignment padding:</simpara>
<formalpara><title>Listing 7</title><para>
<screen>template &lt;std::size_t size_, std::size_t alignment_&gt;
struct aligned_storage_imp
{
    union data_t
    {
        char buf[size_];

        typename mpl::eval_if_c&lt;
              alignment_ == std::size_t(-1)
            , mpl::identity&lt;detail::max_align&gt;
            , type_with_alignment&lt;alignment_&gt;
            &gt;::type align_;
    } data_;
    void* address() const { return const_cast&lt;aligned_storage_imp*&gt;(this); }
};</screen>
</para></formalpara>
<simpara>Typically, depending on the size of the held type, there will be some extra space used (e.g. on 64-bit Win8/VS2012), variant&lt;char&gt; will occupy 8 bytes, while varian&lt;std::string&gt; will occupy 40:</simpara>
<formalpara><title>Listing 8</title><para>
<screen>variant&lt;char&gt;: <co id="CO1-1"/>8
variant&lt;int&gt;: <co id="CO1-2"/>8
variant&lt;float&gt;: <co id="CO1-3"/>8
variant&lt;double&gt;: <co id="CO1-4"/>16
variant&lt;std::string&gt;: <co id="CO1-5"/>40</screen>
</para></formalpara>
<simpara>The most significant constraint of boost::variant is that it can only accept a predefined set of types. If a type is not explicitly listed in declaration (template instantiation) of the variant variable, that type can not be assigned to it.</simpara>
<section id="_comparison_between_boost_variant_and_boost_any">
<title>Comparison between Boost.Variant and Boost.Any</title>
<simpara>For easier understanding of the concepts behind the two classes described so far, boost::any is often compared to "type-safe void*" whereas boost:variant is compared to "type-safe union". While there are certainly similarities, this comparison should be taken cautiously.</simpara>
<section id="_boost_variant_advantages_over_boost_any">
<title>Boost.Variant advantages over Boost.Any:</title>
<itemizedlist>
<listitem>
<simpara>
guarantees the type of its content is one of a finite, user-specified set of types
</simpara>
</listitem>
<listitem>
<simpara>
provides compile-time checked generic visitation of its content (Boost.Any provides no visitation mechanism at all; even if it did, it would need to be checked at run-time)
</simpara>
</listitem>
<listitem>
<simpara>
offers an efficient, stack-based storage scheme (avoiding the overhead of dynamic allocation).
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_boost_any_advantages_over_boost_variant">
<title>Boost.Any advantages over Boost.Variant:</title>
<itemizedlist>
<listitem>
<simpara>
allows any type for its content, providing great flexibility
</simpara>
</listitem>
<listitem>
<simpara>
provides the no-throw guarantee of exception safety for its swap operation
</simpara>
</listitem>
<listitem>
<simpara>
no template meta-programming techniques (avoids potentially hard-to-read error messages and significant compile-time processor and memory demands).
</simpara>
</listitem>
</itemizedlist>
<simpara>While variant offers slightly more cooperation on the extraction side, it is still not seamless; intuitive code won&#8217;t work while the next simplest way is brittle:</simpara>
</section>
</section>
</section>
<section id="_boosttypeerasure">
<title>BoostTypeErasure</title>
<simpara>According to the author, type_erasure addresses the shortcomings of C++ runtime polymorphism, in particular its (1) intrusiveness, (2) dynamic memory management and (3) inability to apply multiple independent concepts to a single object. Library uses some advanced constructs such as concepts and template metaprogramming constructs from boost::mpl. Just like boost::variant specifies a set of types that can be contained within it at construction time, type_erasure specifies a set of operations that can be performed on it:</simpara>
<formalpara><title>Listing 9</title><para>
<screen>any&lt;
    mpl::vector&lt;
        copy_constructible&lt;&gt;,
        typeid_&lt;&gt;,
        incrementable&lt;&gt;,
        ostreamable&lt;&gt;
    &gt;
&gt; x(10);
++x; // incrementable
std::cout &lt;&lt; x &lt;&lt; std::endl; // ostreamable</screen>
</para></formalpara>
</section>
<section id="_facebook_folly_dynamic">
<title>Facebook folly::dynamic</title>
<simpara>The Facebook folly::dynamic class is another one in the spectrum of dynamic-typing-like classes. The class aims to relax the static typing constraints and it is very similar to Poco::Dynamic::Var.</simpara>
<formalpara><title>Listing 10</title><para>
<screen>dynamic twelve = 12; // creates a dynamic that holds an integer
dynamic str = "string"; // yep, this one is an fbstring

// A few other types.
dynamic nul = nullptr;
dynamic boolean = false;

// Arrays can be initialized with brackets.
dynamic array = { "array ", "of ", 4, " elements" };
assert(array.size() == 4);
dynamic emptyArray = {};
assert(array.empty());

// Maps from dynamics to dynamics are called objects.  The
// dynamic::object constant is how you make an empty map from dynamics
// to dynamics.
dynamic map = dynamic::object;
map["something"] = 12;
map["another_something"] = map["something"] * 2;

// Dynamic objects may be intialized this way
dynamic map2 = dynamic::object("something", 12)("another_something", 24);</screen>
</para></formalpara>
</section>
<section id="_poco_dynamic_var">
<title>Poco::Dynamic::Var</title>
<simpara>As mentioned earlier, Poco Dynamic::Var continues where boost::any stops - on the data extraction side.</simpara>
<simpara>In this article, we will also look at other solutions for type erasure, look at their practical uses and compare their interfaces and implementations.</simpara>
<simpara>Type safety is an important feature of C++; type erasure is a necessary technique for modern software development. Session examines and compares existing solutions to these important concerns.</simpara>
<formalpara id="POCOPRJ"><title>References</title><para>[POCOPRJ] C++ Portable Components, <ulink url="http://pocoproject.org">http://pocoproject.org</ulink></para></formalpara>
<simpara id="ROBPIRS">[ROBPIRS] "A brief summary of the Metaphysics of Quality", Robert Pirsig, <ulink url="http://robertpirsig.org/MOQSummary.htm">http://robertpirsig.org/MOQSummary.htm</ulink></simpara>
<simpara id="ACCUDYN">[ACCUDYN] "DynamicAny", Part I and II, Alex Fabijanic, Overload August/October 2008<?asciidoc-br?>
<ulink url="http://accu.org/index.php/journals/1502">http://accu.org/index.php/journals/1502</ulink><?asciidoc-br?>
<ulink url="http://accu.org/index.php/journals/1511">http://accu.org/index.php/journals/1511</ulink></simpara>
<simpara id="DOUBCON">[DOUBCON] "Double-conversion library", <ulink url="http://code.google.com/p/double-conversion/">http://code.google.com/p/double-conversion/</ulink></simpara>
<simpara id="BOOSANY">[BOOSANY] Boost.Any, <ulink url="http://www.boost.org/doc/libs/1_53_0/doc/html/any.html">http://www.boost.org/doc/libs/1_53_0/doc/html/any.html</ulink></simpara>
<simpara id="POCOANY">[POCOANY] Poco::Any, <ulink url="http://pocoproject.org">http://pocoproject.org</ulink></simpara>
<simpara id="ANYCSTD">[ANYCSTD] "Any Library Proposal", Revision 1, Kevlin Henney, Beman Dawes<?asciidoc-br?>
<ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3390.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3390.html</ulink></simpara>
<simpara id="BOOSVAR">[BOOSVAR] "Boost.Variant", Eric Friedman, Itay Maman<?asciidoc-br?>
<ulink url="http://www.boost.org/doc/libs/1_52_0/doc/html/variant.html">http://www.boost.org/doc/libs/1_52_0/doc/html/variant.html</ulink></simpara>
<simpara id="FOLLYDY">[FOLLYDY] Facebook folly dynamic clas<?asciidoc-br?>
<ulink url="https://github.com/facebook/folly/blob/master/folly/docs/Dynamic.md">https://github.com/facebook/folly/blob/master/folly/docs/Dynamic.md</ulink></simpara>
<simpara id="CSHPDYN">[CSHPDYN] C# dynamic<?asciidoc-br?>
<ulink url="http://msdn.microsoft.com/en-us/library/dd264736.aspx">http://msdn.microsoft.com/en-us/library/dd264736.aspx</ulink></simpara>
</section>
</article>
